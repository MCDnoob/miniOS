# 局部变量与参数传递

测试代码：
```C

int add(int x, int y) 
{
    int z = x + y;
    return z;
}

int main()
{
    int a = 5;
    int b = 3;
    int c = add(a, b);
    return 0;
}
```

```S
	.file	"param.c"
	.text
	.globl	add
	.type	add, @function
add:
    ; 保存栈帧
	pushl	%ebp
	movl	%esp, %ebp

	subl	$4, %esp        ; esp-4，增加栈
	movl	8(%ebp), %edx   ; ebp+8->edx, b,a
	movl	12(%ebp), %eax  ; ebp+12->eax, z
	addl	%edx, %eax      ; eax += edx
	movl	%eax, -4(%ebp)  ; eax-> ebp-4
	movl	-4(%ebp), %eax  ; ebp-4->eax ，即返回值z

	leave
	ret
	.size	add, .-add
	.globl	main
	.type	main, @function
main:
    ; 保存栈帧
	pushl	%ebp
	movl	%esp, %ebp

	subl	$12, %esp       ; 栈顶减少12字节，增加栈
	movl	$5, -12(%ebp)   ; a存储到ebp-offset(12)里面(a位于栈顶，虽然栈从上到下增长，但数据依然是从下到上存储的)
	movl	$3, -8(%ebp)    ; b存储到ebp-offset(8)里面
	pushl	-8(%ebp)        ; b 压入栈
	pushl	-12(%ebp)       ; a 压入栈
	call	add             ; 调用函数add
	addl	$8, %esp        ; esp+8，回收栈(变量a和b此时已经死亡)
	movl	%eax, -4(%ebp)  ; eax(add返回值z)-> ebp-4位置
	movl	$0, %eax        ; 设置eax为0

	leave                   ； 恢复栈帧
	ret                     ; 返回
	.size	main, .-main
	.section	.note.GNU-stack,"",@progbits
```

## 栈帧的作用
保护函数局部变量的信息，可用于回溯调用函数，是debug中很关键的设置。

## 主动申请栈内存和栈保护
在C语言中有`alloc`可以直接申请堆栈内存：
```C
int main()
{
    char* ptr = alloca(20);
    ptr[5] = 0xaa;
    return 0;
}
```
编译为汇编代码主要有：
```S
main:
    ...
    movl %gs:20, %eax
    ...
    call	__stack_chk_fail
```
这就是栈保护，会在一开设置一个值，如果程序结束之后栈顶指针超过这个值，就出发栈溢出。
由gcc选项`-fno-stack-protector`设定。

## 寄存器传递参数
**一般不使用寄存器传递参数**，因为有`printf`这样的函数，是无参数限制的。但如果强行使用寄存器，x86可用8个基础寄存器进行传参。系统调用会用寄存器传递参数，效率更高。